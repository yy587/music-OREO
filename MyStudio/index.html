<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素熵 / PIXEL ENTROPY - V13.3 ADAPTIVE</title>
    <style>
        /* --- 1. 全局变量 (CSS Variables) --- */
        :root {
            --bg: #ffffff;              /* 背景色 */
            --surface: #f5f5f7;         /* 卡片背景 */
            --surface-hover: #ebebf0;   /* 悬停背景 */
            --text-primary: #1d1d1f;    /* 主文字 */
            --text-secondary: #86868b;  /* 次级文字 */
            --accent: #0071e3;          /* 强调色 (蓝) */
            --border: #d2d2d7;          /* 浅边框 */
            --border-strong: #a1a1a6;   /* 深边框 (用于强调边界) */
            --shadow: 0 4px 12px rgba(0,0,0,0.05);
            
            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            --font-mono: 'SF Mono', 'JetBrains Mono', 'Courier New', monospace;
        }

        * { box-sizing: border-box; outline: none; -webkit-font-smoothing: antialiased; }

        body {
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-stack);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- 2. 顶部导航栏 --- */
        .navbar {
            position: fixed; top: 0; left: 0; width: 100%; height: 64px;
            background: rgba(255, 255, 255, 0.9); backdrop-filter: saturate(180%) blur(20px);
            border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 30px; z-index: 100;
        }
        
        .brand { 
            font-size: 18px; font-weight: 700; letter-spacing: -0.5px; 
            color: var(--text-primary); display: flex; align-items: center; gap: 10px;
        }
        .brand span { 
            font-weight: 400; font-size: 11px; background: #000; color: #fff; 
            padding: 2px 6px; border-radius: 4px;
        }

        .nav-actions button {
            background: transparent; border: 1px solid var(--border); color: var(--text-primary);
            padding: 6px 14px; border-radius: 6px; font-size: 12px; font-weight: 600;
            cursor: pointer; transition: 0.2s;
        }
        .nav-actions button:hover { background: var(--surface-hover); border-color: var(--border-strong); }

        /* --- 3. 页面容器 --- */
        .page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding-top: 64px; display: flex; flex-direction: column;
            opacity: 0; pointer-events: none; transform: scale(0.99);
            transition: opacity 0.4s ease, transform 0.4s ease;
            background: var(--bg);
        }
        .page.active { opacity: 1; pointer-events: all; transform: scale(1); z-index: 10; }

        /* --- 4. 首页 (Home) - 自适应网格布局 --- */
        #home-page { 
            align-items: center; 
            justify-content: center; /* 垂直居中 */
            padding: 20px; /* 页面外边距 */
            overflow-y: auto; /* 允许垂直滚动 */
        }
        
        /* 标题区域 */
        .home-header { 
            text-align: center; width: 100%; max-width: 900px; 
            margin-bottom: 40px; margin-top: 20px;
        }
        .home-header h1 { font-size: 42px; font-weight: 800; margin: 0 0 12px 0; color: #000; letter-spacing: -1px; }
        .home-header p { font-size: 15px; color: var(--text-secondary); line-height: 1.6; max-width: 600px; margin: 0 auto; }

        /* 核心布局容器：Grid System 
           确保完全显示，不超出边界，且有距离
        */
        .grid-wrapper {
            display: grid;
            /* 自适应列宽：
               - 最小宽度 220px (保证卡片不被挤压太小)
               - 最大宽度 1fr (均分剩余空间)
               - auto-fit (自动填满行)
            */
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px; /* 模块之间的距离 */
            
            width: 100%;
            max-width: 1600px; /* 限制最大宽度，防止在大屏上太散 */
            padding: 20px;     /* 内边距，防止贴边 */
            
            /* 边界线可视化 (可选，用于调试或增加结构感) */
            /* border: 1px dashed var(--border); border-radius: 12px; */
        }

        /* 卡片模块 */
        .card {
            background: #fff;
            /* 高度自适应，或者固定 */
            height: 400px; 
            display: flex; flex-direction: column;
            
            /* 边界线设定 */
            border: 1px solid var(--border);
            border-radius: 16px;
            
            overflow: hidden; 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: var(--shadow);
        }
        
        /* 悬停效果：加深阴影，加深边框 */
        .card:hover { 
            transform: translateY(-6px); 
            box-shadow: 0 20px 40px rgba(0,0,0,0.12);
            border-color: var(--accent); /* 悬停时边框变蓝 */
        }

        /* 图片区域 */
        .card-img-wrap {
            flex: 1; /* 占据剩余空间 */
            background: var(--surface); 
            position: relative; 
            padding: 20px;
            display: flex; align-items: center; justify-content: center;
            border-bottom: 1px solid var(--border); /* 图片和文字区的分隔线 */
        }
        .card-img-wrap img {
            width: 100%; height: 100%; object-fit: contain; 
            transition: transform 0.5s ease; filter: grayscale(100%) contrast(1.1); mix-blend-mode: multiply;
        }
        .card:hover .card-img-wrap img { transform: scale(1.05); filter: grayscale(0%); }
        
        /* 信息区域 */
        .card-info { 
            padding: 20px; 
            height: 110px; /* 固定底部高度，保证整齐 */
            display: flex; flex-direction: column; justify-content: center;
        }
        
        .card-title-row {
            display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;
        }
        .card-title-en { font-size: 18px; font-weight: 700; color: #000; }
        .card-title-cn { 
            font-size: 11px; font-weight: 600; color: var(--accent); 
            background: rgba(0,113,227,0.08); padding: 4px 8px; border-radius: 6px; 
            white-space: nowrap;
        }
        
        .card-desc { 
            font-size: 12px; color: var(--text-secondary); line-height: 1.4; 
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; /* 超过两行省略 */
        }

        /* --- 5. 编辑器 (Editor) --- */
        #editor-page { flex-direction: row; }

        .viewport {
            flex: 1; background: #f0f0f2; display: flex; justify-content: center; align-items: center; 
            position: relative; 
            /* 点阵背景 */
            background-image: radial-gradient(#c7c7cc 1px, transparent 1px); background-size: 20px 20px;
        }
        canvas { 
            box-shadow: 0 20px 60px rgba(0,0,0,0.15); border-radius: 8px; 
            max-width: 90%; max-height: 90%; background: #fff;
            border: 1px solid var(--border); /* 画布边界 */
        }

        .sidebar {
            width: 340px; background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(30px); border-left: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 50;
        }
        
        .sidebar-header {
            padding: 24px; border-bottom: 1px solid var(--border);
            font-size: 12px; font-weight: 700; color: var(--text-primary); letter-spacing: 1px; text-transform: uppercase;
        }

        .controls-scroll { flex: 1; padding: 24px; overflow-y: auto; }

        .control-item { margin-bottom: 32px; }
        .label-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 8px; }
        .label-main { font-size: 13px; font-weight: 600; color: #000; }
        .label-sub { font-size: 11px; color: var(--text-secondary); margin-top: 4px; display: block;}
        .val-display { color: var(--accent); font-family: var(--font-mono); font-size: 12px; font-weight: bold;}

        /* 开关样式 */
        .toggle-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600;}
        input[type="checkbox"] { accent-color: var(--accent); transform: scale(1.2); cursor: pointer;}

        input[type="range"] {
            width: 100%; -webkit-appearance: none; background: #e5e5ea; height: 4px; border-radius: 2px; display: block; margin-top: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 22px; height: 22px; background: #fff; border: 1px solid var(--border);
            border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.15); 
            cursor: pointer; transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }

        .btn-group { padding: 24px; display: grid; gap: 12px; border-top: 1px solid var(--border); background: #fafafa; }
        .btn {
            width: 100%; padding: 14px; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer;
            border: 1px solid transparent; display: flex; justify-content: center; align-items: center; transition: 0.2s;
        }
        .btn-primary { background: #000; color: #fff; }
        .btn-primary:hover { background: #333; }
        .btn-secondary { background: #fff; color: #000; border-color: var(--border); }
        .btn-secondary:hover { background: #f2f2f7; border-color: var(--border-strong); }
        .btn-danger { background: #ff3b30; color: #fff; }

        .audio-player { background: #f2f2f7; border-radius: 12px; padding: 16px; margin-bottom: 30px; border: 1px solid var(--border); }
        .viz-container { height: 30px; display: flex; align-items: flex-end; gap: 3px; margin: 12px 0; }
        .viz-bar { flex: 1; background: #d1d1d6; height: 10%; border-radius: 2px; transition: height 0.05s; }
        .viz-bar.active { background: var(--accent); }

        input[type="file"] { display: none; }
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%; background: #fff; z-index: 200;
            display: none; justify-content: center; align-items: center; color: var(--text-secondary); font-size: 12px;
        }
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="loader">System Initializing...</div>

    <nav class="navbar">
        <div class="brand">像素熵 / PIXEL ENTROPY <span>V13.3</span></div>
        <div class="nav-actions">
            <button id="backBtn" class="hidden" onclick="app.goHome()">← 返回首页 / Back</button>
        </div>
    </nav>

    <div id="home-page" class="page active">
        <div class="home-header">
            <h1>像素熵 / PIXEL ENTROPY</h1>
            <p>在线实验平台，专为创意专业人士设计，旨在将音频数据与图像风格化结合，创造独特的视觉表现。</p>
        </div>

        <div class="grid-wrapper">
            
            <div class="card" onclick="app.loadMode('polka')">
                <div class="card-img-wrap">
                    <img src="images/polka_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=Polka'" alt="Polka">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">Polka Dot</span>
                        <span class="card-title-cn">波普圆点</span>
                    </div>
                    <div class="card-desc">半调网点效果，通过圆点大小模拟灰度，致敬波普艺术。</div>
                </div>
            </div>

            <div class="card" onclick="app.loadMode('ascii')">
                <div class="card-img-wrap">
                    <img src="images/ascii_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=ASCII'" alt="ASCII">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">ASCII</span>
                        <span class="card-title-cn">字符重构</span>
                    </div>
                    <div class="card-desc">将图像转化为纯文本数据流，探索字符的灰度表现力。</div>
                </div>
            </div>

            <div class="card" onclick="app.loadMode('dither')">
                <div class="card-img-wrap">
                    <img src="images/dither_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=Dither'" alt="Dither">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">Dither</span>
                        <span class="card-title-cn">抖动算法</span>
                    </div>
                    <div class="card-desc">模拟复古印刷质感，使用 1-bit 像素点阵重组图像。</div>
                </div>
            </div>

            <div class="card" onclick="app.loadMode('thermal')">
                <div class="card-img-wrap">
                    <img src="images/thermal_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=Thermal'" alt="Thermal">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">Thermal</span>
                        <span class="card-title-cn">热成像</span>
                    </div>
                    <div class="card-desc">基于亮度的热力图映射，创造高饱和度的迷幻视觉。</div>
                </div>
            </div>

            <div class="card" onclick="app.loadMode('glitch')">
                <div class="card-img-wrap">
                    <img src="images/glitch_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=Glitch'" alt="Glitch">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">Glitch</span>
                        <span class="card-title-cn">故障艺术</span>
                    </div>
                    <div class="card-desc">模拟信号传输错误，产生数据错位与 RGB 色彩分离。</div>
                </div>
            </div>

            <div class="card" onclick="app.loadMode('particles')">
                <div class="card-img-wrap">
                    <img src="images/particle_preview.png" onerror="this.src='https://placehold.co/500x300/eee/999?text=Particles'" alt="Particles">
                </div>
                <div class="card-info">
                    <div class="card-title-row">
                        <span class="card-title-en">Particles</span>
                        <span class="card-title-cn">声波粒子</span>
                    </div>
                    <div class="card-desc">音频驱动的物理引擎，粒子随音乐律动与重组。</div>
                </div>
            </div>

        </div>
    </div>

    <div id="editor-page" class="page hidden">
        <div class="viewport">
            <canvas id="canvas"></canvas>
        </div>

        <div class="sidebar">
            <div class="sidebar-header" id="modeTitle">PARAMETERS</div>
            
            <div class="controls-scroll" id="controls">
                </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">导入图片 / Import</button>
                <button class="btn btn-primary" id="exportBtn" onclick="app.export()">导出图片 / Export</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*">
    <input type="file" id="audioInput" accept="audio/*">

    <script>
        const PARAM_LABELS = {
            polka: { scale: {en:"Grid Size", cn:"网格大小"}, dotSize: {en:"Dot Size", cn:"圆点大小"}, color: {en:"Color", cn:"彩色模式"} },
            ascii: { scale: {en:"Scale", cn:"字符大小"}, contrast: {en:"Contrast", cn:"对比度"} },
            dither: { scale: {en:"Grid Size", cn:"网格大小"}, intensity: {en:"Threshold", cn:"黑白阈值"} },
            thermal: { threshold: {en:"Threshold", cn:"色阶断点"}, bloom: {en:"Bloom", cn:"辉光强度"} },
            glitch: { amount: {en:"Amount", cn:"故障强度"}, seed: {en:"Seed", cn:"随机种子"}, rgbShift: {en:"RGB Shift", cn:"色差偏移"} },
            particles: { density: {en:"Density", cn:"粒子间距"}, reaction: {en:"Reaction", cn:"音频响应"}, scatter: {en:"Scatter", cn:"扩散程度"} }
        };

        class App {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.img = new Image();
                this.originalData = null;
                this.mode = null;
                this.animId = null;

                this.params = {
                    polka: { scale: 12, dotSize: 1.0, color: true },
                    ascii: { scale: 8, contrast: 1.2 },
                    dither: { scale: 4, intensity: 128 }, 
                    thermal: { threshold: 120, bloom: 20 },
                    glitch: { amount: 20, seed: 50, rgbShift: 5 },
                    particles: { density: 12, reaction: 60, scatter: 20 }
                };

                this.audioCtx = null;
                this.audioEl = new Audio();
                this.audioEl.crossOrigin = "anonymous"; this.audioEl.loop = true;
                this.analyser = null;
                this.destNode = null;
                this.mediaRecorder = null;
                this.isRecording = false;

                this.initEvents();
                // 默认占位
                this.img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%23f5f5f7'/%3E%3Ccircle cx='400' cy='300' r='150' fill='%231d1d1f'/%3E%3C/svg%3E";
                this.img.onload = () => {};
            }

            loadMode(mode) {
                this.mode = mode;
                document.getElementById('home-page').classList.remove('active');
                const editor = document.getElementById('editor-page');
                const backBtn = document.getElementById('backBtn');
                editor.classList.remove('hidden');
                void editor.offsetWidth;
                editor.classList.add('active');
                backBtn.classList.remove('hidden');
                document.getElementById('modeTitle').innerText = mode.toUpperCase() + " SETTINGS";
                this.buildUI();
                setTimeout(() => {
                    this.resizeCanvas();
                    if(mode === 'particles') { this.initParticles(); this.loop(); } else { this.stopLoop(); this.render(); }
                }, 100);
            }

            goHome() {
                this.stopLoop();
                if(!this.audioEl.paused) this.toggleAudio();
                const home = document.getElementById('home-page');
                const editor = document.getElementById('editor-page');
                const backBtn = document.getElementById('backBtn');
                editor.classList.remove('active');
                home.classList.add('active');
                backBtn.classList.add('hidden');
                setTimeout(() => editor.classList.add('hidden'), 400);
            }

            buildUI() {
                const container = document.getElementById('controls');
                container.innerHTML = '';
                
                const expBtn = document.getElementById('exportBtn');
                if(this.mode === 'particles') {
                    expBtn.innerText = "录制 2K 视频 / Record";
                    expBtn.className = "btn btn-danger";
                } else {
                    expBtn.innerText = "导出图片 / Export";
                    expBtn.className = "btn btn-primary";
                }

                if(this.mode === 'particles') {
                    const audioPanel = document.createElement('div');
                    audioPanel.className = 'audio-player';
                    audioPanel.innerHTML = `
                        <div class="label-row"><span class="label-main">AUDIO</span><span class="label-sub">音频输入</span></div>
                        <div class="viz-container" id="vizBars"></div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                            <button class="btn btn-secondary" style="padding:8px" onclick="document.getElementById('audioInput').click()">Load MP3</button>
                            <button class="btn btn-secondary" style="padding:8px" id="playBtn" onclick="app.toggleAudio()">Play</button>
                        </div>`;
                    container.appendChild(audioPanel);
                    setTimeout(() => {
                        const viz = document.getElementById('vizBars');
                        for(let i=0; i<20; i++) { const b = document.createElement('div'); b.className='viz-bar'; viz.appendChild(b); }
                    }, 0);
                }

                const p = this.params[this.mode];
                const labels = PARAM_LABELS[this.mode];
                Object.keys(p).forEach(key => {
                    const div = document.createElement('div');
                    div.className = 'control-item';
                    const val = p[key];
                    const label = labels[key] || {en:key, cn:""};

                    if (typeof val === 'boolean') {
                        div.innerHTML = `
                            <div class="toggle-row">
                                <div><div class="label-main">${label.en}</div><span class="label-sub">${label.cn}</span></div>
                                <input type="checkbox" ${val?'checked':''}>
                            </div>`;
                        container.appendChild(div);
                        div.querySelector('input').addEventListener('change', (e)=>{ p[key] = e.target.checked; this.render(); });
                    } else {
                        let min=1, max=100, step=1;
                        if(key==='scale'||key==='density') {max=60; min=4;}
                        if(key==='contrast'||key==='dotSize') {max=3; min=0.1; step=0.1;}
                        if(key==='intensity') {max=255; min=0; step=1;}
                        
                        div.innerHTML = `
                            <div class="label-row">
                                <div><div class="label-main">${label.en}</div><span class="label-sub">${label.cn}</span></div>
                                <span class="val-display" id="val-${key}">${val}</span>
                            </div>
                            <input type="range" min="${min}" max="${max}" step="${step}" value="${val}">`;
                        container.appendChild(div);
                        div.querySelector('input').addEventListener('input', (e)=>{
                            const v = parseFloat(e.target.value);
                            p[key] = v;
                            document.getElementById(`val-${key}`).innerText = v;
                            if(this.mode==='particles' && key==='density') this.initParticles();
                            else if(this.mode!=='particles') this.render();
                        });
                    }
                });
            }

            resizeCanvas() {
                if(!this.img.width) return;
                const container = document.querySelector('.viewport');
                const maxWidth = container.clientWidth - 80;
                const maxHeight = container.clientHeight - 80;
                let w = this.img.width, h = this.img.height;
                const ratio = w/h;
                if(w > maxWidth) { w = maxWidth; h = w/ratio; }
                if(h > maxHeight) { h = maxHeight; w = h*ratio; }
                this.canvas.width = w; this.canvas.height = h;
                this.ctx.drawImage(this.img, 0, 0, w, h);
                this.originalData = this.ctx.getImageData(0,0,w,h);
            }

            render() {
                if(!this.originalData) return;
                const w = this.canvas.width, h = this.canvas.height;
                this.ctx.fillStyle = '#fff'; this.ctx.fillRect(0,0,w,h);
                switch(this.mode) {
                    case 'polka': this.drawPolka(w,h); break;
                    case 'ascii': this.drawAscii(w,h); break;
                    case 'dither': this.drawDither(w,h); break;
                    case 'thermal': this.drawThermal(w,h); break;
                    case 'glitch': this.drawGlitch(w,h); break;
                }
            }

            drawPolka(w,h) {
                const p = this.params.polka;
                const step = p.scale;
                const d = this.originalData.data;
                for(let y=0; y<h; y+=step) {
                    for(let x=0; x<w; x+=step) {
                        const i = (Math.floor(y)*w + Math.floor(x))*4;
                        if(i>=d.length) continue;
                        const r=d[i], g=d[i+1], b=d[i+2];
                        const bright = (r+g+b)/3/255;
                        const radius = (step/2)*(1-bright)*p.dotSize;
                        if(radius>0.5) {
                            this.ctx.beginPath(); this.ctx.arc(x+step/2, y+step/2, radius, 0, Math.PI*2);
                            this.ctx.fillStyle = p.color ? `rgb(${r},${g},${b})` : '#000';
                            this.ctx.fill();
                        }
                    }
                }
            }

            drawAscii(w,h) {
                const p = this.params.ascii; const step = p.scale;
                const chars = " .'`^\",:;Il!i~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
                this.ctx.font = `bold ${step}px monospace`; this.ctx.textBaseline='top'; this.ctx.fillStyle='#000';
                const d = this.originalData.data;
                for(let y=0; y<h; y+=step) {
                    for(let x=0; x<w; x+=step) {
                        const i=(y*w+x)*4; if(i>=d.length) continue;
                        let b = (d[i]+d[i+1]+d[i+2])/3/255;
                        b = (b-0.5)*p.contrast+0.5; b=Math.max(0, Math.min(1,b));
                        const idx = Math.floor((1-b)*(chars.length-1));
                        if(idx>0) this.ctx.fillText(chars[idx], x, y);
                    }
                }
            }

            drawDither(w,h) {
                const p = this.params.dither; const scl = p.scale; const thres = p.intensity;
                const tmp = document.createElement('canvas'); tmp.width=Math.ceil(w/scl); tmp.height=Math.ceil(h/scl);
                const tctx = tmp.getContext('2d'); tctx.drawImage(this.img,0,0,tmp.width,tmp.height);
                const id = tctx.getImageData(0,0,tmp.width,tmp.height); const d=id.data;
                for(let i=0; i<d.length; i+=4) {
                    const gray = (d[i]+d[i+1]+d[i+2])/3;
                    const v = gray < thres ? 0 : 255;
                    d[i]=d[i+1]=d[i+2]=v;
                }
                tctx.putImageData(id,0,0);
                this.ctx.imageSmoothingEnabled=false; this.ctx.drawImage(tmp,0,0,w,h);
            }

            drawThermal(w,h) {
                const p=this.params.thermal; const d=this.originalData.data;
                const id=this.ctx.createImageData(w,h); const out=id.data;
                for(let i=0; i<d.length; i+=4) {
                    const b=(d[i]+d[i+1]+d[i+2])/3;
                    if(b<p.threshold) { out[i]=0; out[i+1]=0; out[i+2]=100; }
                    else if(b<p.threshold+50) { out[i]=150; out[i+1]=0; out[i+2]=150; }
                    else { out[i]=255; out[i+1]=200; out[i+2]=50; }
                    out[i+3]=255;
                }
                this.ctx.putImageData(id,0,0);
                if(p.bloom>0) { this.ctx.filter=`blur(${p.bloom}px)`; this.ctx.globalCompositeOperation='lighter'; this.ctx.drawImage(this.canvas,0,0); this.ctx.filter='none'; this.ctx.globalCompositeOperation='source-over'; }
            }

            drawGlitch(w,h) {
                const p=this.params.glitch; this.ctx.drawImage(this.img,0,0,w,h);
                const slices = p.amount;
                for(let i=0; i<slices; i++) {
                    const y=Math.random()*h; const sh=Math.random()*30+1; const xoff=(Math.random()-0.5)*50;
                    this.ctx.drawImage(this.canvas,0,y,w,sh,xoff,y,w,sh);
                }
                if(p.rgbShift>0) {
                    this.ctx.globalCompositeOperation='multiply';
                    this.ctx.fillStyle=`rgba(255,0,0,0.3)`; this.ctx.fillRect(p.rgbShift,0,w,h);
                    this.ctx.globalCompositeOperation='source-over';
                }
            }

            initParticles() {
                this.particles = []; const p=this.params.particles; const d=this.originalData.data; const den=p.density;
                for(let y=0; y<this.canvas.height; y+=den) {
                    for(let x=0; x<this.canvas.width; x+=den) {
                        const i=(y*this.canvas.width+x)*4;
                        if(d[i]<240) this.particles.push({x:x, y:y, ox:x, oy:y, col:`rgb(${d[i]},${d[i+1]},${d[i+2]})`, size:Math.random()*2+1});
                    }
                }
            }

            loop() {
                if(this.mode!=='particles') return;
                this.ctx.fillStyle='rgba(255,255,255,0.4)'; this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                let amp=0;
                if(this.analyser) {
                    const arr=new Uint8Array(this.analyser.frequencyBinCount); this.analyser.getByteFrequencyData(arr);
                    let sum=0; for(let i=0; i<20; i++) sum+=arr[i]; amp=sum/20; this.updateViz(arr);
                }
                const force=(amp/255)*this.params.particles.reaction;
                for(let pt of this.particles) {
                    let dx=pt.ox-pt.x; let dy=pt.oy-pt.y; pt.x+=dx*0.1; pt.y+=dy*0.1;
                    if(force>5) {
                        const nx=(Math.random()-0.5)*this.params.particles.scatter*(force/5);
                        const ny=(Math.random()-0.5)*this.params.particles.scatter*(force/5);
                        pt.x+=nx; pt.y-=force+ny;
                    }
                    this.ctx.fillStyle=pt.col; this.ctx.fillRect(pt.x, pt.y, pt.size, pt.size);
                }
                this.animId=requestAnimationFrame(()=>this.loop());
            }

            stopLoop() { if(this.animId) cancelAnimationFrame(this.animId); }

            toggleAudio() {
                if(!this.audioCtx) {
                    this.audioCtx=new AudioContext(); this.analyser=this.audioCtx.createAnalyser(); this.analyser.fftSize=64;
                    this.destNode=this.audioCtx.createMediaStreamDestination();
                    const src=this.audioCtx.createMediaElementSource(this.audioEl);
                    src.connect(this.analyser); this.analyser.connect(this.audioCtx.destination); src.connect(this.destNode);
                }
                if(this.audioCtx.state==='suspended') this.audioCtx.resume();
                const btn=document.getElementById('playBtn');
                if(this.audioEl.paused) { this.audioEl.play(); btn.innerText="Pause"; } else { this.audioEl.pause(); btn.innerText="Play"; }
            }

            updateViz(data) {
                const bars=document.getElementById('vizBars').children; if(!bars.length) return;
                const step=Math.floor(data.length/20);
                for(let i=0; i<Math.min(20,bars.length); i++) {
                    const h=(data[i*step]/255)*100; bars[i].style.height=h+'%';
                    if(h>50) bars[i].classList.add('active'); else bars[i].classList.remove('active');
                }
            }

            export() {
                if(this.mode==='particles') {
                    if(this.isRecording) {
                        this.mediaRecorder.stop(); this.isRecording=false;
                        document.getElementById('exportBtn').innerText="Record Video";
                        document.getElementById('exportBtn').className="btn btn-danger";
                    } else {
                        if(this.audioEl.paused) { alert("Please play music first."); return; }
                        const stream=this.canvas.captureStream(60);
                        if(this.destNode) { const t=this.destNode.stream.getAudioTracks()[0]; if(t) stream.addTrack(t); }
                        this.mediaRecorder=new MediaRecorder(stream, {mimeType:'video/webm; codecs=vp9', videoBitsPerSecond:8000000});
                        this.mediaRecorder.ondataavailable=e=>{
                            if(e.data.size>0) { const u=URL.createObjectURL(e.data); const a=document.createElement('a'); a.href=u; a.download='render.webm'; a.click(); }
                        };
                        this.mediaRecorder.start(); this.isRecording=true;
                        document.getElementById('exportBtn').innerText="Stop Recording";
                        document.getElementById('exportBtn').className="btn btn-primary";
                    }
                } else {
                    const a=document.createElement('a'); a.download=`pixel_entropy_${Date.now()}.png`;
                    a.href=this.canvas.toDataURL(); a.click();
                }
            }

            initEvents() {
                document.getElementById('fileInput').addEventListener('change', e=>{
                    const f=e.target.files[0]; if(f){
                        const r=new FileReader(); r.onload=ev=>{
                            this.img.src=ev.target.result;
                            this.img.onload=()=>{ this.resizeCanvas(); if(this.mode==='particles') this.initParticles(); else this.render(); }
                        }; r.readAsDataURL(f);
                    }
                });
                document.getElementById('audioInput').addEventListener('change', e=>{ const f=e.target.files[0]; if(f) this.audioEl.src=URL.createObjectURL(f); });
            }
        }

        const app = new App();
    </script>
</body>
</html>

